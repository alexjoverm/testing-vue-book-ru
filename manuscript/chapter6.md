# Тестирование методов и имитация зависимостей

В этой главе узнаем, как тестировать методы и справляться с имитацией зависимостями модулей.

Что мы должны тестировать в методах? Это вопрос мы задали себе, когда мы начали выполнять модульные тесты. Все сводится к тому, чтобы **проверить, что делает этот метод, и только это**. Это означает, что нам нужно **избегать вызовов любой зависимости**, поэтому нам нужно их имитировать (mock).

Давайте добавим событие `onSubmit` в форме компонента` Form.vue`, который мы создали в [предыдущей главе](#chapter-5):

```html
<!-- ... -->
<form action="" @submit.prevent="onSubmit(inputValue)">
<!-- ... -->
```

Модификатор `.prevent` — это просто удобный способ вызвать `event.preventDefault()`, чтобы не перезагружать страницу. Теперь внесите некоторые изменения, чтобы сделать запрос к API в метод `onSubmit` и сохранить результат с данными в массив `results`:

The `.prevent` modifier is just a convenient way to call `event.preventDefault()` in order to don't reload the page. Now make some modifications to call an api and store the result, by adding a `results` array to the data and a `onSubmit` method:

```javascript
data: () => ({
  inputValue: '',
  results: []
}),
methods: {
  onSubmit(value) {
    axios.get('https://jsonplaceholder.typicode.com/posts?q=' + value).then(results => {
      this.results = results.data
    })
  }
},
// ...
```

Метод использует axios для выполнения HTTP-вызова конечной точки «posts» <http://jsonplaceholder.typicode.com>, которая является всего лишь RESTful API для такого рода примеров, с параметром запроса `q` мы можем искать посты, используя предоставленный `value` в виде параметра.

Для тестирования метода `onSubmit`:

- Мы не хотим вызывать фактический метод `axios.get`
- Мы хотим проверить, что он вызывает axios (но не настоящие), и он возвращает промис
- Этот колбэк промиса должен установить `this.results` результат промиса

Это, вероятно, одно из самое тяжелое в тестировании, когда у вас есть внешние зависимости, а также те промисы, которые делают что-то внутри. Что нам нужно сделать, это **имитировать внешние зависимости**.

## Имитация зависимостей внешних модулей

Jest предоставляет действительно отличную систему, которая позволяет вам имитировать все довольно удобным способом. Для этого вам не нужны дополнительные библиотеки. Мы уже видели `jest.spyOn` и `jest.fn` для создания шпионов и создания функций-заглушек, хотя этого недостаточно для данного случая.

Нам нужно имитировать весь модуль `axios`. Вот тут `jest.mock` выходит на сцену. Это позволяет нам легко имитировать зависимости модулей, написав в верхней части файла:

```javascript
jest.mock('dependency-path', implementationFunction)
```

Вам следует знать, что **`jest.mock` поднят**, что означает, что он будет помещен наверху. Поэтому:

```javascript
jest.mock('something', jest.fn)
import foo from 'bar'
// ...
```

Эквивалентно:

```javascript
import foo from 'bar'
jest.mock('something', jest.fn) // это в конечном итоге превысит импорт и все
// ...
```

К дате написания я все еще не видел много информации в Интернете о том, как сделать в Jest то, что мы собираемся делать сейчас. К счастью, вам не нужно проходить ту же борьбу.

Давайте напишем имитацию для axios в верхней части тестового файла `Form.test.js` и соответствующий тестовый пример:

```javascript
jest.mock('axios', () => ({
  get: jest.fn()
}))

import { shallowMount } from '@vue/test-utils'
import Form from '../src/components/Form'
import axios from 'axios' // axios здесь, но их имитация вверху!

// ...

it('Вызывает axios.get', () => {
  cmp.vm.onSubmit('an')
  expect(axios.get).toBeCalledWith('https://jsonplaceholder.typicode.com/posts?q=an')
})
```

Это здорово, мы на самом деле создали имитацию для axios, поэтому оригинальная библиотека axios не вызывает ни один HTTP-запрос. И мы даже проверяем с помощью `toBeCalledWith`, что он был вызван с правильными параметрами. Но мы все еще что-то упустили: **_мы не проверяем, что он возвращает обещание_**.

Сначала нам нужно сделать так, чтобы наш подстановочный метод `axios.get` возвращал промис. `jest.fn` принимает фабричную функцию в виде параметра, поэтому мы можем использовать ее для определения реализации:

```javascript
jest.mock('axios', () => ({
  get: jest.fn(() => Promise.resolve({ data: 3 }))
}))
```

Но тем не менее, мы не можем получить доступ к промису, потому что мы его не возвращаем. При тестировании хорошей практикой является возможность вернуть что-то из функции, когда это возможно, что значительно облегчает тестирование. Давайте сделаем это в методе `onSubmit` компонента `Form.vue`:

```javascript
onSubmit(value) {
  const getPromise = axios.get('https://jsonplaceholder.typicode.com/posts?q=' + value)

  getPromise.then(results => {
    this.results = results.data
  })

  return getPromise
}
```

Затем мы можем использовать предельно понятный синтаксис из ES2017 `async/await` в тесте для проверки результата промиса:

```javascript
it('Вызывает axios.get и проверяет результат промиса', async () => {
  const result = await cmp.vm.onSubmit('an')

  expect(result).toEqual({ data: [3] })
  expect(cmp.vm.results).toEqual([3])
  expect(axios.get).toBeCalledWith('https://jsonplaceholder.typicode.com/posts?q=an')
})
```

Вы можете видеть, что мы не только проверяем результат промиса, но также и то, что внутреннее состояние компонента `results` обновляется, как и ожидалось, путем выполнения `expect(cmp.vm.results).toEqual([3])`.

## Держите макеты экстернализированными

Jest позволяет нам разделять все наши подстановочные объекты в отдельном JavaScript-файле, помещая их в папку `__mocks__`, чтобы тесты были максимально чистыми и понятными.

Поэтому мы можем взять блок `jest.mock...` из файла `Form.test.js` и перенести в собственный файл:

```javascript
// test/__mocks__/axios.js
module.exports = {
  get: jest.fn(() => Promise.resolve({ data: [3] }))
}
```

Точно так же, без каких-либо дополнительных усилий, Jest автоматически применяет подстановочный объект во всех наших тестах, поэтому нам не нужно делать что-либо лишнее или изменять тесты. Обратите внимание, что имя модуля должно совпадать с именем файла. Если вы снова запустите тесты, они все равно должны пройти.

Имейте в виду, что реестр модулей и состояние подстановочного объекта сохранены, поэтому, если вы впоследствии напишите еще один тест, вы можете получить нежелательные результаты:

```javascript
it('Вызывает axios.get', async () => {
  const result = await cmp.vm.onSubmit('an')

  expect(result).toEqual({ data: [3] })
  expect(cmp.vm.results).toEqual([3])
  expect(axios.get).toBeCalledWith('https://jsonplaceholder.typicode.com/posts?q=an')
})

it('Axios не должен быть вызван в данном случае', () => {
  expect(axios.get).toBeCalledWith('https://jsonplaceholder.typicode.com/posts?q=an')
})
```

Второй тест должен потерпеть неудачу, но это не так! Это потому, что `axios.get` был вызван на тест раньше.

По этой причине, это хорошая практика, чтобы очистить реестр модулей и все подстановочные объекты, поскольку ими управляет Jest для имитации их реализации. Для этого вы можете добавить в свой `beforeEach`:

```javascript
beforeEach(() => {
  cmp = shallowMount(Form)
  jest.resetModules()
  jest.clearAllMocks()
})
```

Теперь каждый тест будет начинаться с чистых подстаночных объектов и модулей, как это и должно быть в модульном тестировании.

## Резюме

Функционал имитации Jest, наряду с моментальным снимком, — это то, что я люблю больше всего в Jest! С его помощью очень легко протестировать то, что обычно довольно сложно поддаётся тестированию, а также сосредоточиться на написании более быстрых и лучших изолированных тестов и сохранить свою кодовую базу пуленепробиваемой.

Код этой главы можно найти в [этом репозитории](https://github.com/alexjoverm/vue-testing-series/tree/Test-State-Computed-Properties-and-Methods-in-Vue-js-Components-with-Jest).