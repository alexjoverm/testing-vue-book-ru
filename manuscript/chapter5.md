# Тестирование вычисляемых свойств и наблюдателей в компонентах Vue.js {#chapter-5}

В этой главе вы узнаете о тестировании реактивности вычисляемых свойств и наблюдателей во Vue.js.

Вычисляемые свойства и наблюдатели — реактивные части логики компонентов Vue.js. Они оба предназначены для достижения совершенно других целей, один для синхронной, а другой для асинхронной, что делает их поведение несколько иным.

## Вычисляемые свойства

Вычисляемые свойства — это простые реактивные функции, которые возвращают данные в другой форме. Они ведут себя точно так же, как стандартные свойства `get/set` в языке:

```javascript
class X {
  // ...

  get fullName() {
    return `${this.name} ${this.surname}`
  }

  set fullName() {
    // ...
  }
}
```

Фактически, когда вы создаете компоненты Vue на основе классов, как я объясняю в своем [курсе на Egghead «Использование TypeScript для разработки веб-приложений Vue.js»] (https://egghead.io/courses/use-typescript-to-develop-vue-js-web-applications) (на английском), вы напишете вычисляемые свойства именно так. Если вы используете обычные объекты, это будет так, как показано ниже:

```javascript
export default {
  // ...
  computed: {
    fullName() {
      return `${this.name} ${this.surname}`
    }
  }
}
```

И вы даже можете добавить `set` следующим образом:

```javascript
computed: {
    fullName: {
      get() {
        return `${this.name} ${this.surname}`
      },
      set() {
        // ...
      }
    }
  }
```

### Тестирование вычисляемых свойств

Тестирование вычисляемого свойства очень просто и, возможно, иногда вы тестируете не только конкретно вычисляемое свойство, а как её как часть других тестов. Но в большинстве случаев неплохо иметь тесты для подобных свойств, независимо от того, что вычисляемое свойство очищает входное поле ввода или объединяет данные, поэтому мы хотим убедиться, что все работает должным образом. Итак, давайте начнем.

Прежде всего, создайте компонент `Form.vue`:

```html
<template>
  <div>
    <form action="">
      <input type="text" v-model="inputValue">
      <span class="reversed">{{ reversedInput }}</span>
    </form>
  </div>
</template>

<script>
export default {
  props: ['reversed'],
  data: () => ({
    inputValue: ''
  }),
  computed: {
    reversedInput() {
      return this.reversed ?
        this.inputValue.split('').reverse().join('') :
        this.inputValue
    }
  }
}
</script>
```

Он будет показывать введённое в поле ввода значение, а рядом с ним ту же строку, но перевернутую наоборот. Это всего лишь простой пример, но это достаточно для проверки вычисляемого свойства.

Теперь сделайте изменения в `App.vue`, импортировав созданный компонент `Form` сразу после `MessageList` и не забудьте включить его в свойство объекта `components`. Затем создайте `test/Form.test.js` со стандартной заглушкой, которую мы уже использовали в других тестах:

```javascript
import { shallowMount } from '@vue/test-utils'
import Form from '../src/components/Form'

describe('Form.test.js', () => {
  let cmp

  beforeEach(() => {
    cmp = shallowMount(Form)
  })
})
```

Теперь создайте набор тестов с двумя тестовыми сценариями:

```javascript
describe('Свойства', () => {
  it('возвращает строку в обычном порядке, если свойство reversed не равняется true', () => {
      cmp.setData({ inputValue: 'Yoo' })
      expect(cmp.vm.reversedInput).toBe('Yoo')
  })

  it('возвращает перевернутую строку, если свойство reversed равняется true', () => {
      cmp.setData({ inputValue: 'Yoo' })
      cmp.setProps({ reversed: true })
      expect(cmp.vm.reversedInput).toBe('ooY')
  })
})
```

Мы можем получить доступ к экземпляру компонента в `cmp.vm`, т.е. к внутреннему свойству, вычисляемым свойствам и методам. Теперь для тестирования, нам просто нужно изменить значение и убедиться, что возвращается одинаковая строка, если входной параметр `reversed` равен `false`.

Второй тестовый сценарий во многом похож на первым, лишь за тем исключением, что мы устанавливаем для свойства `reverseed` значение `true`. Мы могли бы использовать `cmp.vm ...` для изменения входного параметра, но `vue-test-utils` предоставляет нам вспомогательный метод `setProps({ property: value, ... })`, что довольно просто для использования.

Вот и все, в зависимости от вычисляемого свойства, может потребоваться больше тестовых сценариев.

## Наблюдатели

Честно говоря, я не сталкивался ни с одним случаем, когда мне действительно нужно было использовать наблюдателей, где бы вычисляемые свойства не смогли справиться. Я тоже видел как ими злоупотребляют, что приведет к очень нечеткому потоку данных между компонентами и запутыванию всего, поэтому не спешите использовать их и подумайте заранее.

Honestly, I haven't come across any case where I really need to use watchers that I computed properties couldn't solve. I've seen them misused as well, leading to a very unclear data workflow among components and messing everything up, so don't rush on using them and think beforehand.

Как вы можете видеть в [документации Vue.js](https://ru.vuejs.org/v2/guide/computed.html#%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-%D0%BD%D0%B0%D0%B1%D0%BB%D1%8E%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D0%B8), наблюдатели часто используются для реагирования на изменения данных и выполнения асинхронных операций, например, это может быть выполнение AJAX-запросов.

### Тестирование наблюдателей

Предположим, мы хотим что-то сделать, когда изменится `inputValue` из состояния. Мы могли бы выполнить AJAX-запрос, но поскольку это более сложно, и мы увидим это в следующем уроке, а пока давайте просто напишем `console.log`. Добавьте свойство `watch` в опции компонента `Form.vue`:

```javascript
watch: {
  inputValue(newVal, oldVal) {
    if (newVal.trim().length && newVal !== oldVal) {
      console.log(newVal)
    }
  }
}
```

Обратите внимание, что функция-наблюдатель `inputValue` соответствует имени переменной состояния. По соглашению, Vue будет искать его в состоянии объектов `properties` и `data`, используя имя watch-функции, в этом случае это `inputValue`, который можно найти в `data`, и он добавит наблюдателя туда.

Посмотрите, функция-наблюдатель принимает новое значение в качестве первого параметра, а старый — вторым. В данном случае мы решили логировать только тогда, когда новое значение не пустое, а её значение отличается от старого значения. Обычно мы хотели бы написать тест для каждого случая, в зависимости от времени, сколько у вас тестов и насколько критичен этот код.

Что мы должны протестировать в функции-наблюдателе? Ну, об этом мы еще поговорим далее в следующем уроке, когда затронем методы тестирования, но предположим, что мы просто хотим знать, что она вызывает `console.log`, когда это нужно. Итак, давайте добавим заготовку для набора тестов наблюдателей в `Form.test.js`:

```javascript
describe('Form.test.js', () => {
  let cmp
  // ...

  describe('Наблюдатели - inputValue', () => {
    let spy

    beforeAll(() => {
      spy = jest.spyOn(console, 'log')
    })

    afterEach(() => {
      spy.mockClear()
    })

    it('не вызывается, если значение пустое (с удалением пробелов)', () => {
    })

    it('не вызывается, если значение одно и то же', () => {
    })

    it('вызывается с новым значением в других случаях', () => {
    })
  })
})
```

Мы используем шпион дял метода `console.log`, инициализируем его перед началом каждого теста и перезапускаем его состояние после каждого из них, чтобы они начинались с нового шпиона.

Для тестирования функции-наблюдателя, нам просто нужно изменить значение на другое, которое установлено для наблюдателя, в данном случае это состояние `inputValue`. Но здесь есть кое-что странное... давайте начнем с последнего теста.

```javascript
it('вызывается с новым значением в других случаях', () => {
  cmp.setData({ inputValue: 'foo' })
  expect(spy).toBeCalled()
})
```

Мы изменяем значение `inputValue`, поэтому теперь нужно вызвать шпиона `console.log`, правильно? Хорошо, если вы запустите этот тест, то заметите, что нет! Какого чёрта??? Подождите, есть объяснение: в отличие от вычисляемых свойств наблюдатели **откладываются до следующего цикла обновления**, который Vue использует для поиска изменений. Получается здесь происходит то, что `console.log` действительно вызывается, но после завершения теста.

Чтобы решить эту проблему, нам нужно использовать функцию [`vm.$nextTick`](https://ru.vuejs.org/v2/api/#vm-nextTick), чтобы отложить код до следующего цикла обновления. Но если мы напишем:

```javascript
it('вызывается с новым значением в других случаях', () => {
  cmp.setData({ inputValue: 'foo' })
  cmp.vm.$nextTick(() => {
    expect(spy).toBeCalled()
  })
})
```

Тест по-прежнему будет терпеть неудачу, так как он заканчивается, когда функция `expect` ещё не вызывается. Так происходит потому что теперь тест выполняется асинхронно и проверка находится в колбэке `$nextTick`. Как мы можем теперь провести тестирование, если ожидание с проверкой произойдет позднее?

Jest предоставляет нам параметр `next`, который мы можем использовать в колбэках `it`, таким образом, что если он присутствует, тест не завершится до тех пор, пока не будет вызван `next`, но если это не так, тест завершится синхронно , Итак, чтобы, наконец, понять:

```javascript
it('вызывается с новым значением в других случаях', next => {
  cmp.setData({ inputValue: 'foo' })
  cmp.vm.$nextTick(() => {
    expect(spy).toBeCalled()
    next()
  })
})
```

Мы можем применить ту же стратегию для двух других тестов, с той разницей, что шпион не следует вызывать:

```javascript
it('не вызывается, если значение пустое (с удалением пробелов)', next => {
  cmp.setData({ inputValue: '   ' })
  cmp.vm.$nextTick(() => {
    expect(spy).not.toBeCalled()
    next()
  })
})

it('не вызывается, если значение одно и то же', next => {
  cmp.setData({ inputValue: 'foo' })

  cmp.vm.$nextTick(() => {
    spy.mockClear()
    cmp.setData({ inputValue: 'foo' })
    
    cmp.vm.$nextTick(() => {
      expect(spy).not.toBeCalled()
      next()
    })
  })
})
```

Этот второй `$nextTick` будет немного сложнее, чем выглядит. Внутреннее состояние по умолчанию пустое, поэтому сначала нам нужно его изменить, дождаться следующего тика, затем очистить mock-объект, чтобы сбросить количество вызовов, и изменим `inputValue` снова. Затем, после второго тика, мы можем проверить шпиона и закончить тест.

Это может быть проще, если мы пересоздадим компонент в самом начале, переопределив свойство `data`. Помните, что вы можете переопределить любую опцию компонента, используя второй параметр функций `mount` или `shallowMount`:

```javascript
it('не вызывается, если значение одно и то же', next => {
  cmp = shallowMount(Form, {
    data: () => ({ inputValue: 'foo' })
  })
  cmp.setData({ inputValue: 'foo' })
  cmp.vm.$nextTick(() => {
    expect(spy).not.toBeCalled()
    next()
  })
})
```

## Резюме

В этой главе вы узнали, как тестировать часть логики компонентов Vue: вычисляемые свойства и наблюдатели. Мы разобрали различные тестовые сценарии, с которыми вы можете столкнуться, проверяя их. Вероятно, вы также изучили некоторые внутренние функции Vue, такие как циклы обновления `nextTick`.

Код этой статьи можно найти в [этом репозитории](https://github.com/alexjoverm/vue-testing-series/tree/Test-State-Computed-Properties-and-Methods-in-Vue-js-Components-with-Jest).
`